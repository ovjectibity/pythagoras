<!DOCTYPE html>
                  <html>
                  <head>
                    <meta charset="utf-8">
                    <title>Basquiat</title>
                    <link rel="preconnect" href="https://fonts.googleapis.com">
                    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
                    <style>
                  /* src/ui/ui.css */
* {
  box-sizing: border-box;
}
body {
  font-family:
    "Inter",
    -apple-system,
    BlinkMacSystemFont,
    sans-serif;
  margin: 0;
  padding: 0;
  background: #2c2c2c;
  overflow: hidden;
  border-radius: 8px;
}
.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100%;
}
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 12px;
  border-bottom: 1px solid #444444;
  background: #2c2c2c;
  font-size: 11px;
  margin: 0;
  color: #ffffff;
}
.header-actions {
  display: flex;
  gap: 8px;
}
.icon-button {
  padding: 6px;
  border: 1px solid #383838;
  background-color: #2c2c2c;
  color: #ffffff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
}
.icon-button:hover {
  background-color: #383838;
}
.messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.empty-state {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #2c2c2c;
  font-size: 12px;
}
.message {
  max-width: 85%;
  display: flex;
}
.message.user {
  align-self: flex-end;
}
.message.assistant {
  align-self: flex-start;
}
.message-content {
  padding: 10px 12px;
  font-size: 12px;
  line-height: 1.5;
  word-wrap: break-word;
}
.message.user .message-content {
  background-color: #2c2c2c;
  color: #2c2c2c;
}
.message.assistant .message-content {
  background-color: #2c2c2c;
  color: #2c2c2c;
}
.message-content.loading {
  display: flex;
  gap: 4px;
}
.dot {
  animation: blink 1.4s infinite;
}
.dot:nth-child(2) {
  animation-delay: 0.2s;
}
.dot:nth-child(3) {
  animation-delay: 0.4s;
}
@keyframes blink {
  0%, 60%, 100% {
    opacity: 0.3;
  }
  30% {
    opacity: 1;
  }
}
.input-container {
  display: flex;
  flex-direction: column;
  border-top: 1px solid #444444;
  padding: 12px 12px;
  background: #2c2c2c;
  gap: 10px;
}
.textarea-wrapper {
  width: 100%;
  border: 1px solid #383838;
}
.input-area {
  width: 100%;
  background: #2c2c2c;
  border: none;
  padding: 8px 12px;
  font-size: 12px;
  font-family: inherit;
  color: #ffffff;
  line-height: 1.5;
  min-height: calc(1.5em + 16px);
  max-height: calc(7.5em + 16px);
  overflow-y: auto;
  overflow-wrap: break-word;
  white-space: pre-wrap;
}
.input-area:empty:before {
  content: attr(data-placeholder);
  color: #b3b3b3;
}
.input-area.disabled {
  cursor: not-allowed;
  opacity: 0.6;
  pointer-events: none;
}
.input-area:focus {
  outline: none;
  background: #383838;
}
.input-controls {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}
.send-button {
  padding: 6px 0px;
  border: 1px solid #383838;
  background-color: #2c2c2c;
  color: #ffffff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  width: 36px;
  height: 36px;
}
.send-button:hover {
  background-color: #383838;
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown.disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.dropdown-trigger {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  background: #2c2c2c;
  color: #ffffff;
  border: none;
  font-size: 11px;
  font-family: inherit;
  cursor: pointer;
  white-space: nowrap;
}
.dropdown-trigger:disabled {
  cursor: not-allowed;
}
.dropdown-trigger .chevron {
  transition: transform 0.2s;
}
.dropdown-trigger .chevron.open {
  transform: rotate(180deg);
}
.dropdown-list {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: calc(100% + 4px);
  left: 0;
  background: #1e1e1e;
  border: 1px solid #383838;
  border-radius: 8px;
  gap: 2px;
  padding: 12px;
  min-width: 100%;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
.dropdown-list.position-up {
  top: auto;
  bottom: calc(100% + 4px);
}
.dropdown-item {
  display: block;
  width: 100%;
  padding: 6px 8px;
  background: transparent;
  border-radius: 8px;
  color: #ffffff;
  border: none;
  font-size: 11px;
  font-family: inherit;
  text-align: left;
  cursor: pointer;
  white-space: nowrap;
}
.dropdown-item:hover {
  background: #383838;
}
.dropdown-item.selected {
  background: #2c2c2c;
}

                    </style>
                  </head>
                  <body>
                    <script>
                  "use strict";
(() => {
  // node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }

  // node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class _ResizeObserverSingleton {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element2, listener) {
      this._listeners.set(element2, listener);
      this._getObserver().observe(element2, this.options);
      return () => {
        this._listeners.delete(element2);
        this._observer.unobserve(element2);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          _ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function stop_propagation(fn) {
    return function(event) {
      event.stopPropagation();
      return fn.call(this, event);
    };
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data)
      return;
    text2.data = /** @type {string} */
    data;
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function toggle_class(element2, name, toggle) {
    element2.classList.toggle(name, !!toggle);
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }
  function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, event));
    }
  }

  // node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  function add_flush_callback(fn) {
    flush_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$$);
        }
      } catch (e) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }

  // node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
      // parent group
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  // node_modules/svelte/src/runtime/internal/each.js
  function ensure_array_like(array_like_or_iterator) {
    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }

  // node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // node_modules/svelte/src/runtime/internal/Component.js
  function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== void 0) {
      component.$$.bound[index] = callback;
      callback(component.$$.ctx[index]);
    }
  }
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      flush_render_callbacks($$.after_update);
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance7, create_fragment7, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment7 ? create_fragment7($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $$ctor;
      /** Slots */
      $$s;
      /** The Svelte component instance */
      $$c;
      /** Whether or not the custom element is connected */
      $$cn = false;
      /** Component props data */
      $$d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $$r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $$p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $$l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $$l_u = /* @__PURE__ */ new Map();
      constructor($$componentCtor, $$slots, use_shadow_dom) {
        super();
        this.$$ctor = $$componentCtor;
        this.$$s = $$slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$$l[type] = this.$$l[type] || [];
        this.$$l[type].push(listener);
        if (this.$$c) {
          const unsub = this.$$c.$on(type, listener);
          this.$$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$$c) {
          const unsub = this.$$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$$l_u.delete(listener);
          }
        }
        if (this.$$l[type]) {
          const idx = this.$$l[type].indexOf(listener);
          if (idx >= 0) {
            this.$$l[type].splice(idx, 1);
          }
        }
      }
      async connectedCallback() {
        this.$$cn = true;
        if (!this.$$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$$cn || this.$$c) {
            return;
          }
          const $$slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$$s) {
            if (name in existing_slots) {
              $$slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$$g_p(attribute.name);
            if (!(name in this.$$d)) {
              this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
            }
          }
          for (const key in this.$$p_d) {
            if (!(key in this.$$d) && this[key] !== void 0) {
              this.$$d[key] = this[key];
              delete this[key];
            }
          }
          this.$$c = new this.$$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$$d,
              $$slots,
              $$scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$$r = true;
            for (const key in this.$$p_d) {
              this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
              if (this.$$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$$d[key],
                  this.$$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$$r = false;
          };
          this.$$c.$$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$$l) {
            for (const listener of this.$$l[type]) {
              const unsub = this.$$c.$on(type, listener);
              this.$$l_u.set(listener, unsub);
            }
          }
          this.$$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$$r)
          return;
        attr2 = this.$$g_p(attr2);
        this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
        this.$$c?.$set({ [attr2]: this.$$d[attr2] });
      }
      disconnectedCallback() {
        this.$$cn = false;
        Promise.resolve().then(() => {
          if (!this.$$cn && this.$$c) {
            this.$$c.$destroy();
            this.$$c = void 0;
          }
        });
      }
      $$g_p(attribute_name) {
        return Object.keys(this.$$p_d).find(
          (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $$ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $$set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$$set && !is_empty(props)) {
        this.$$.skip_bound = true;
        this.$$set(props);
        this.$$.skip_bound = false;
      }
    }
  };

  // node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // src/ui/dropdown.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[12] = list[i];
    return child_ctx;
  }
  function create_if_block(ctx) {
    let div;
    let each_value = ensure_array_like(
      /*items*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "dropdown-list");
        toggle_class(
          div,
          "position-up",
          /*position*/
          ctx[3] === "up"
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*items, selectedValue, selectItem*/
        131) {
          each_value = ensure_array_like(
            /*items*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
        if (dirty & /*position*/
        8) {
          toggle_class(
            div,
            "position-up",
            /*position*/
            ctx2[3] === "up"
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block(ctx) {
    let button;
    let t0_value = (
      /*item*/
      ctx[12].label + ""
    );
    let t0;
    let t1;
    let mounted;
    let dispose;
    function click_handler() {
      return (
        /*click_handler*/
        ctx[11](
          /*item*/
          ctx[12]
        )
      );
    }
    return {
      c() {
        button = element("button");
        t0 = text(t0_value);
        t1 = space();
        attr(button, "class", "dropdown-item");
        attr(button, "type", "button");
        toggle_class(
          button,
          "selected",
          /*item*/
          ctx[12].value === /*selectedValue*/
          ctx[1]
        );
      },
      m(target, anchor) {
        insert(target, button, anchor);
        append(button, t0);
        append(button, t1);
        if (!mounted) {
          dispose = listen(button, "click", click_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & /*items*/
        1 && t0_value !== (t0_value = /*item*/
        ctx[12].label + ""))
          set_data(t0, t0_value);
        if (dirty & /*items, selectedValue*/
        3) {
          toggle_class(
            button,
            "selected",
            /*item*/
            ctx[12].value === /*selectedValue*/
            ctx[1]
          );
        }
      },
      d(detaching) {
        if (detaching) {
          detach(button);
        }
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment(ctx) {
    let div;
    let button;
    let span;
    let t0;
    let t1;
    let svg;
    let path;
    let t2;
    let mounted;
    let dispose;
    let if_block = (
      /*isOpen*/
      ctx[4] && create_if_block(ctx)
    );
    return {
      c() {
        div = element("div");
        button = element("button");
        span = element("span");
        t0 = text(
          /*selectedLabel*/
          ctx[5]
        );
        t1 = space();
        svg = svg_element("svg");
        path = svg_element("path");
        t2 = space();
        if (if_block)
          if_block.c();
        attr(path, "d", "M3 4.5L6 7.5L9 4.5");
        attr(path, "stroke", "currentColor");
        attr(path, "stroke-width", "1.5");
        attr(path, "stroke-linecap", "round");
        attr(path, "stroke-linejoin", "round");
        attr(svg, "width", "12");
        attr(svg, "height", "12");
        attr(svg, "viewBox", "0 0 12 12");
        attr(svg, "fill", "none");
        attr(svg, "class", "chevron");
        toggle_class(
          svg,
          "open",
          /*isOpen*/
          ctx[4]
        );
        attr(button, "class", "dropdown-trigger");
        button.disabled = /*disabled*/
        ctx[2];
        attr(button, "type", "button");
        attr(div, "class", "dropdown");
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[2]
        );
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, button);
        append(button, span);
        append(span, t0);
        append(button, t1);
        append(button, svg);
        append(svg, path);
        append(div, t2);
        if (if_block)
          if_block.m(div, null);
        if (!mounted) {
          dispose = [
            listen(
              window,
              "click",
              /*handleClickOutside*/
              ctx[8]
            ),
            listen(button, "click", stop_propagation(
              /*toggleDropdown*/
              ctx[6]
            ))
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & /*selectedLabel*/
        32)
          set_data(
            t0,
            /*selectedLabel*/
            ctx2[5]
          );
        if (dirty & /*isOpen*/
        16) {
          toggle_class(
            svg,
            "open",
            /*isOpen*/
            ctx2[4]
          );
        }
        if (dirty & /*disabled*/
        4) {
          button.disabled = /*disabled*/
          ctx2[2];
        }
        if (
          /*isOpen*/
          ctx2[4]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(div, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
        if (dirty & /*disabled*/
        4) {
          toggle_class(
            div,
            "disabled",
            /*disabled*/
            ctx2[2]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if (if_block)
          if_block.d();
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance($$self, $$props, $$invalidate) {
    let selectedLabel;
    var _a;
    let { items } = $$props;
    let { selectedValue } = $$props;
    let { onSelect } = $$props;
    let { disabled = false } = $$props;
    let { position = "down" } = $$props;
    let isOpen = false;
    function toggleDropdown() {
      if (!disabled) {
        $$invalidate(4, isOpen = !isOpen);
      }
    }
    function selectItem(value) {
      onSelect(value);
      $$invalidate(4, isOpen = false);
    }
    function handleClickOutside(event) {
      const target = event.target;
      if (!target.closest(".dropdown")) {
        $$invalidate(4, isOpen = false);
      }
    }
    const click_handler = (item) => selectItem(item.value);
    $$self.$$set = ($$props2) => {
      if ("items" in $$props2)
        $$invalidate(0, items = $$props2.items);
      if ("selectedValue" in $$props2)
        $$invalidate(1, selectedValue = $$props2.selectedValue);
      if ("onSelect" in $$props2)
        $$invalidate(9, onSelect = $$props2.onSelect);
      if ("disabled" in $$props2)
        $$invalidate(2, disabled = $$props2.disabled);
      if ("position" in $$props2)
        $$invalidate(3, position = $$props2.position);
    };
    $$self.$$.update = () => {
      if ($$self.$$.dirty & /*items, selectedValue, _a*/
      1027) {
        $:
          $$invalidate(5, selectedLabel = ($$invalidate(10, _a = items.find((item) => item.value === selectedValue)) === null || _a === void 0 ? void 0 : _a.label) || "");
      }
    };
    return [
      items,
      selectedValue,
      disabled,
      position,
      isOpen,
      selectedLabel,
      toggleDropdown,
      selectItem,
      handleClickOutside,
      onSelect,
      _a,
      click_handler
    ];
  }
  var Dropdown = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {
        items: 0,
        selectedValue: 1,
        onSelect: 9,
        disabled: 2,
        position: 3
      });
    }
  };
  var dropdown_default = Dropdown;

  // src/ui/header.svelte
  function create_fragment2(ctx) {
    let div1;
    let dropdown;
    let t0;
    let div0;
    let current;
    dropdown = new dropdown_default({
      props: {
        items: (
          /*chatOptions*/
          ctx[2]
        ),
        selectedValue: (
          /*selectedChat*/
          ctx[0]
        ),
        onSelect: (
          /*onChatChange*/
          ctx[1]
        ),
        position: "down"
      }
    });
    return {
      c() {
        div1 = element("div");
        create_component(dropdown.$$.fragment);
        t0 = space();
        div0 = element("div");
        div0.innerHTML = `<button class="icon-button" title="New"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M8 3V13M3 8H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg></button> <button class="icon-button" title="More"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="4" r="1" fill="currentColor"></circle><circle cx="8" cy="8" r="1" fill="currentColor"></circle><circle cx="8" cy="12" r="1" fill="currentColor"></circle></svg></button>`;
        attr(div0, "class", "header-actions");
        attr(div1, "class", "header");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        mount_component(dropdown, div1, null);
        append(div1, t0);
        append(div1, div0);
        current = true;
      },
      p(ctx2, [dirty]) {
        const dropdown_changes = {};
        if (dirty & /*selectedChat*/
        1)
          dropdown_changes.selectedValue = /*selectedChat*/
          ctx2[0];
        if (dirty & /*onChatChange*/
        2)
          dropdown_changes.onSelect = /*onChatChange*/
          ctx2[1];
        dropdown.$set(dropdown_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(dropdown.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(dropdown.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_component(dropdown);
      }
    };
  }
  function instance2($$self, $$props, $$invalidate) {
    let { selectedChat } = $$props;
    let { onChatChange: onChatChange2 } = $$props;
    const chatOptions = [
      { value: "chat-1", label: "Chat 1" },
      { value: "chat-2", label: "Chat 2" },
      { value: "chat-3", label: "Chat 3" }
    ];
    $$self.$$set = ($$props2) => {
      if ("selectedChat" in $$props2)
        $$invalidate(0, selectedChat = $$props2.selectedChat);
      if ("onChatChange" in $$props2)
        $$invalidate(1, onChatChange2 = $$props2.onChatChange);
    };
    return [selectedChat, onChatChange2, chatOptions];
  }
  var Header = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, { selectedChat: 0, onChatChange: 1 });
    }
  };
  var header_default = Header;

  // src/ui/messages.svelte
  function get_each_context2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[2] = list[i];
    return child_ctx;
  }
  function create_else_block(ctx) {
    let each_1_anchor;
    let each_value = ensure_array_like(
      /*messages*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
    }
    return {
      c() {
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        each_1_anchor = empty();
      },
      m(target, anchor) {
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(target, anchor);
          }
        }
        insert(target, each_1_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*messages*/
        1) {
          each_value = ensure_array_like(
            /*messages*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context2(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block2(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(each_1_anchor);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_if_block_1(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.innerHTML = `<p>Start a conversation to modify your Figma design</p>`;
        attr(div, "class", "empty-state");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_each_block2(ctx) {
    let div1;
    let div0;
    let t;
    let div1_class_value;
    return {
      c() {
        div1 = element("div");
        div0 = element("div");
        div0.innerHTML = ``;
        t = space();
        attr(div0, "class", "message-content");
        attr(div1, "class", div1_class_value = "message " + /*message*/
        ctx[2].role);
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, div0);
        append(div1, t);
      },
      p(ctx2, dirty) {
        if (dirty & /*messages*/
        1 && div1_class_value !== (div1_class_value = "message " + /*message*/
        ctx2[2].role)) {
          attr(div1, "class", div1_class_value);
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  function create_if_block2(ctx) {
    let div1;
    return {
      c() {
        div1 = element("div");
        div1.innerHTML = `<div class="message-content loading"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>`;
        attr(div1, "class", "message assistant");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
      }
    };
  }
  function create_fragment3(ctx) {
    let div;
    let t;
    function select_block_type(ctx2, dirty) {
      if (
        /*messages*/
        ctx2[0].length === 0
      )
        return create_if_block_1;
      return create_else_block;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block0 = current_block_type(ctx);
    let if_block1 = (
      /*isLoading*/
      ctx[1] && create_if_block2(ctx)
    );
    return {
      c() {
        div = element("div");
        if_block0.c();
        t = space();
        if (if_block1)
          if_block1.c();
        attr(div, "class", "messages");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if_block0.m(div, null);
        append(div, t);
        if (if_block1)
          if_block1.m(div, null);
      },
      p(ctx2, [dirty]) {
        if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx2);
          if (if_block0) {
            if_block0.c();
            if_block0.m(div, t);
          }
        }
        if (
          /*isLoading*/
          ctx2[1]
        ) {
          if (if_block1) {
          } else {
            if_block1 = create_if_block2(ctx2);
            if_block1.c();
            if_block1.m(div, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        if_block0.d();
        if (if_block1)
          if_block1.d();
      }
    };
  }
  function instance3($$self, $$props, $$invalidate) {
    let { messages } = $$props;
    let { isLoading: isLoading2 } = $$props;
    $$self.$$set = ($$props2) => {
      if ("messages" in $$props2)
        $$invalidate(0, messages = $$props2.messages);
      if ("isLoading" in $$props2)
        $$invalidate(1, isLoading2 = $$props2.isLoading);
    };
    return [messages, isLoading2];
  }
  var Messages = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, { messages: 0, isLoading: 1 });
    }
  };
  var messages_default = Messages;

  // src/ui/input.svelte
  function create_fragment4(ctx) {
    let div3;
    let div1;
    let div0;
    let t0;
    let div2;
    let dropdown;
    let t1;
    let button;
    let svg;
    let path;
    let button_disabled_value;
    let current;
    let mounted;
    let dispose;
    dropdown = new dropdown_default({
      props: {
        items: (
          /*modelOptions*/
          ctx[6]
        ),
        selectedValue: (
          /*selectedModel*/
          ctx[4]
        ),
        onSelect: (
          /*onModelChange*/
          ctx[5]
        ),
        disabled: (
          /*isLoading*/
          ctx[1]
        ),
        position: "up"
      }
    });
    return {
      c() {
        div3 = element("div");
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        div2 = element("div");
        create_component(dropdown.$$.fragment);
        t1 = space();
        button = element("button");
        svg = svg_element("svg");
        path = svg_element("path");
        attr(div0, "class", "input-area");
        attr(div0, "contenteditable", "true");
        attr(div0, "data-placeholder", "Describe the changes you want to make...");
        attr(div0, "role", "textbox");
        attr(div0, "tabindex", "0");
        if (
          /*userInput*/
          ctx[0] === void 0
        )
          add_render_callback(() => (
            /*div0_input_handler*/
            ctx[7].call(div0)
          ));
        toggle_class(
          div0,
          "disabled",
          /*isLoading*/
          ctx[1]
        );
        attr(div1, "class", "textarea-wrapper");
        attr(path, "d", "M3 8H13M13 8L9 4M13 8L9 12");
        attr(path, "stroke", "currentColor");
        attr(path, "stroke-width", "1.5");
        attr(path, "stroke-linecap", "round");
        attr(path, "stroke-linejoin", "round");
        attr(svg, "width", "16");
        attr(svg, "height", "16");
        attr(svg, "viewBox", "0 0 16 16");
        attr(svg, "fill", "none");
        attr(button, "class", "send-button");
        button.disabled = button_disabled_value = !/*userInput*/
        ctx[0].trim() || /*isLoading*/
        ctx[1];
        attr(div2, "class", "input-controls");
        attr(div3, "class", "input-container");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        append(div3, div1);
        append(div1, div0);
        if (
          /*userInput*/
          ctx[0] !== void 0
        ) {
          div0.textContent = /*userInput*/
          ctx[0];
        }
        append(div3, t0);
        append(div3, div2);
        mount_component(dropdown, div2, null);
        append(div2, t1);
        append(div2, button);
        append(button, svg);
        append(svg, path);
        current = true;
        if (!mounted) {
          dispose = [
            listen(
              div0,
              "input",
              /*div0_input_handler*/
              ctx[7]
            ),
            listen(div0, "keypress", function() {
              if (is_function(
                /*onKeyPress*/
                ctx[3]
              ))
                ctx[3].apply(this, arguments);
            }),
            listen(button, "click", function() {
              if (is_function(
                /*onSend*/
                ctx[2]
              ))
                ctx[2].apply(this, arguments);
            })
          ];
          mounted = true;
        }
      },
      p(new_ctx, [dirty]) {
        ctx = new_ctx;
        if (dirty & /*userInput*/
        1 && /*userInput*/
        ctx[0] !== div0.textContent) {
          div0.textContent = /*userInput*/
          ctx[0];
        }
        if (!current || dirty & /*isLoading*/
        2) {
          toggle_class(
            div0,
            "disabled",
            /*isLoading*/
            ctx[1]
          );
        }
        const dropdown_changes = {};
        if (dirty & /*selectedModel*/
        16)
          dropdown_changes.selectedValue = /*selectedModel*/
          ctx[4];
        if (dirty & /*onModelChange*/
        32)
          dropdown_changes.onSelect = /*onModelChange*/
          ctx[5];
        if (dirty & /*isLoading*/
        2)
          dropdown_changes.disabled = /*isLoading*/
          ctx[1];
        dropdown.$set(dropdown_changes);
        if (!current || dirty & /*userInput, isLoading*/
        3 && button_disabled_value !== (button_disabled_value = !/*userInput*/
        ctx[0].trim() || /*isLoading*/
        ctx[1])) {
          button.disabled = button_disabled_value;
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(dropdown.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(dropdown.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div3);
        }
        destroy_component(dropdown);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance4($$self, $$props, $$invalidate) {
    let { userInput } = $$props;
    let { isLoading: isLoading2 } = $$props;
    let { onSend } = $$props;
    let { onKeyPress } = $$props;
    let { selectedModel } = $$props;
    let { onModelChange } = $$props;
    const modelOptions = [
      {
        value: "claude-opus-4",
        label: "Claude Opus 4"
      },
      {
        value: "claude-sonnet-4",
        label: "Claude Sonnet 4"
      },
      {
        value: "claude-haiku-4",
        label: "Claude Haiku 4"
      }
    ];
    function div0_input_handler() {
      userInput = this.textContent;
      $$invalidate(0, userInput);
    }
    $$self.$$set = ($$props2) => {
      if ("userInput" in $$props2)
        $$invalidate(0, userInput = $$props2.userInput);
      if ("isLoading" in $$props2)
        $$invalidate(1, isLoading2 = $$props2.isLoading);
      if ("onSend" in $$props2)
        $$invalidate(2, onSend = $$props2.onSend);
      if ("onKeyPress" in $$props2)
        $$invalidate(3, onKeyPress = $$props2.onKeyPress);
      if ("selectedModel" in $$props2)
        $$invalidate(4, selectedModel = $$props2.selectedModel);
      if ("onModelChange" in $$props2)
        $$invalidate(5, onModelChange = $$props2.onModelChange);
    };
    return [
      userInput,
      isLoading2,
      onSend,
      onKeyPress,
      selectedModel,
      onModelChange,
      modelOptions,
      div0_input_handler
    ];
  }
  var Input = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, {
        userInput: 0,
        isLoading: 1,
        onSend: 2,
        onKeyPress: 3,
        selectedModel: 4,
        onModelChange: 5
      });
    }
  };
  var input_default = Input;

  // src/ui/settings.svelte
  function create_fragment5(ctx) {
    let div4;
    let div3;
    let div0;
    let h2;
    let t1;
    let button0;
    let t2;
    let div1;
    let label;
    let t4;
    let input;
    let t5;
    let p;
    let t8;
    let div2;
    let button1;
    let t10;
    let button2;
    let mounted;
    let dispose;
    return {
      c() {
        div4 = element("div");
        div3 = element("div");
        div0 = element("div");
        h2 = element("h2");
        h2.textContent = "Settings";
        t1 = space();
        button0 = element("button");
        button0.innerHTML = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>`;
        t2 = space();
        div1 = element("div");
        label = element("label");
        label.textContent = "Anthropic API Key";
        t4 = space();
        input = element("input");
        t5 = space();
        p = element("p");
        p.innerHTML = `Get your API key from <a href="https://console.anthropic.com/" target="_blank">console.anthropic.com</a>`;
        t8 = space();
        div2 = element("div");
        button1 = element("button");
        button1.textContent = "Cancel";
        t10 = space();
        button2 = element("button");
        button2.textContent = "Save";
        attr(button0, "class", "icon-button");
        attr(div0, "class", "modal-header");
        attr(label, "for", "apiKey");
        attr(input, "id", "apiKey");
        attr(input, "type", "password");
        attr(input, "placeholder", "sk-ant-...");
        attr(p, "class", "help-text");
        attr(div1, "class", "modal-body");
        attr(button1, "class", "secondary");
        attr(button2, "class", "primary");
        attr(div2, "class", "modal-footer");
        attr(div3, "class", "modal");
        attr(div4, "class", "modal-overlay");
      },
      m(target, anchor) {
        insert(target, div4, anchor);
        append(div4, div3);
        append(div3, div0);
        append(div0, h2);
        append(div0, t1);
        append(div0, button0);
        append(div3, t2);
        append(div3, div1);
        append(div1, label);
        append(div1, t4);
        append(div1, input);
        set_input_value(
          input,
          /*apiKey*/
          ctx[0]
        );
        append(div1, t5);
        append(div1, p);
        append(div3, t8);
        append(div3, div2);
        append(div2, button1);
        append(div2, t10);
        append(div2, button2);
        if (!mounted) {
          dispose = [
            listen(button0, "click", function() {
              if (is_function(
                /*onClose*/
                ctx[1]
              ))
                ctx[1].apply(this, arguments);
            }),
            listen(
              input,
              "input",
              /*input_input_handler*/
              ctx[4]
            ),
            listen(button1, "click", function() {
              if (is_function(
                /*onClose*/
                ctx[1]
              ))
                ctx[1].apply(this, arguments);
            }),
            listen(button2, "click", function() {
              if (is_function(
                /*onSave*/
                ctx[2]
              ))
                ctx[2].apply(this, arguments);
            }),
            listen(div3, "click", stop_propagation(
              /*click_handler*/
              ctx[3]
            )),
            listen(div4, "click", function() {
              if (is_function(
                /*onClose*/
                ctx[1]
              ))
                ctx[1].apply(this, arguments);
            })
          ];
          mounted = true;
        }
      },
      p(new_ctx, [dirty]) {
        ctx = new_ctx;
        if (dirty & /*apiKey*/
        1 && input.value !== /*apiKey*/
        ctx[0]) {
          set_input_value(
            input,
            /*apiKey*/
            ctx[0]
          );
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(div4);
        }
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance5($$self, $$props, $$invalidate) {
    let { apiKey } = $$props;
    let { onClose } = $$props;
    let { onSave } = $$props;
    function click_handler(event) {
      bubble.call(this, $$self, event);
    }
    function input_input_handler() {
      apiKey = this.value;
      $$invalidate(0, apiKey);
    }
    $$self.$$set = ($$props2) => {
      if ("apiKey" in $$props2)
        $$invalidate(0, apiKey = $$props2.apiKey);
      if ("onClose" in $$props2)
        $$invalidate(1, onClose = $$props2.onClose);
      if ("onSave" in $$props2)
        $$invalidate(2, onSave = $$props2.onSave);
    };
    return [apiKey, onClose, onSave, click_handler, input_input_handler];
  }
  var Settings = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment5, safe_not_equal, { apiKey: 0, onClose: 1, onSave: 2 });
    }
  };
  var settings_default = Settings;

  // src/ui/App.svelte
  function create_if_block3(ctx) {
    let settings;
    let updating_apiKey;
    let current;
    function settings_apiKey_binding(value) {
      ctx[9](value);
    }
    let settings_props = {
      onClose: (
        /*toggleSettings*/
        ctx[4]
      ),
      onSave: (
        /*saveApiKey*/
        ctx[5]
      )
    };
    if (
      /*apiKey*/
      ctx[0] !== void 0
    ) {
      settings_props.apiKey = /*apiKey*/
      ctx[0];
    }
    settings = new settings_default({ props: settings_props });
    binding_callbacks.push(() => bind(settings, "apiKey", settings_apiKey_binding));
    return {
      c() {
        create_component(settings.$$.fragment);
      },
      m(target, anchor) {
        mount_component(settings, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const settings_changes = {};
        if (!updating_apiKey && dirty & /*apiKey*/
        1) {
          updating_apiKey = true;
          settings_changes.apiKey = /*apiKey*/
          ctx2[0];
          add_flush_callback(() => updating_apiKey = false);
        }
        settings.$set(settings_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(settings.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(settings.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(settings, detaching);
      }
    };
  }
  function create_fragment6(ctx) {
    let div;
    let header;
    let t0;
    let messages_1;
    let t1;
    let input;
    let updating_userInput;
    let t2;
    let current;
    header = new header_default({
      props: {
        onSettingsClick: (
          /*toggleSettings*/
          ctx[4]
        ),
        selectedChat: "chat-1",
        onChatChange
      }
    });
    messages_1 = new messages_default({
      props: { messages: (
        /*messages*/
        ctx[2]
      ), isLoading }
    });
    function input_userInput_binding(value) {
      ctx[8](value);
    }
    let input_props = {
      isLoading,
      onSend: (
        /*sendMessage*/
        ctx[7]
      ),
      onKeyPress: (
        /*handleKeyPress*/
        ctx[6]
      ),
      selectedModel: "claude-opus-4",
      onModelChange: onModeChange
    };
    if (
      /*userInput*/
      ctx[1] !== void 0
    ) {
      input_props.userInput = /*userInput*/
      ctx[1];
    }
    input = new input_default({ props: input_props });
    binding_callbacks.push(() => bind(input, "userInput", input_userInput_binding));
    let if_block = (
      /*showSettings*/
      ctx[3] && create_if_block3(ctx)
    );
    return {
      c() {
        div = element("div");
        create_component(header.$$.fragment);
        t0 = space();
        create_component(messages_1.$$.fragment);
        t1 = space();
        create_component(input.$$.fragment);
        t2 = space();
        if (if_block)
          if_block.c();
        attr(div, "class", "app");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(header, div, null);
        append(div, t0);
        mount_component(messages_1, div, null);
        append(div, t1);
        mount_component(input, div, null);
        append(div, t2);
        if (if_block)
          if_block.m(div, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        const messages_1_changes = {};
        if (dirty & /*messages*/
        4)
          messages_1_changes.messages = /*messages*/
          ctx2[2];
        messages_1.$set(messages_1_changes);
        const input_changes = {};
        if (!updating_userInput && dirty & /*userInput*/
        2) {
          updating_userInput = true;
          input_changes.userInput = /*userInput*/
          ctx2[1];
          add_flush_callback(() => updating_userInput = false);
        }
        input.$set(input_changes);
        if (
          /*showSettings*/
          ctx2[3]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*showSettings*/
            8) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block3(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(header.$$.fragment, local);
        transition_in(messages_1.$$.fragment, local);
        transition_in(input.$$.fragment, local);
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(header.$$.fragment, local);
        transition_out(messages_1.$$.fragment, local);
        transition_out(input.$$.fragment, local);
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(header);
        destroy_component(messages_1);
        destroy_component(input);
        if (if_block)
          if_block.d();
      }
    };
  }
  var isLoading = false;
  function onModeChange(model) {
  }
  function onChatChange(chat) {
  }
  function instance6($$self, $$props, $$invalidate) {
    let apiKey = "";
    let userInput = "";
    let messages = [];
    let showSettings = false;
    onMount(() => {
      try {
        console.log("App mounted");
        const savedKey = localStorage.getItem("anthropic_api_key");
        if (savedKey) {
          $$invalidate(0, apiKey = savedKey);
        }
      } catch (error) {
        console.error("Error in onMount:", error);
      }
    });
    function toggleSettings() {
      $$invalidate(3, showSettings = !showSettings);
    }
    function saveApiKey() {
      localStorage.setItem("anthropic_api_key", apiKey);
      $$invalidate(3, showSettings = false);
    }
    function handleKeyPress(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }
    async function sendMessage() {
      if (!userInput.trim() || isLoading)
        return;
      if (!apiKey) {
        alert("Please set your API key in settings first");
        $$invalidate(3, showSettings = true);
        return;
      }
      const message = userInput.trim();
      $$invalidate(1, userInput = "");
    }
    function clearChat() {
      $$invalidate(2, messages = []);
    }
    function input_userInput_binding(value) {
      userInput = value;
      $$invalidate(1, userInput);
    }
    function settings_apiKey_binding(value) {
      apiKey = value;
      $$invalidate(0, apiKey);
    }
    return [
      apiKey,
      userInput,
      messages,
      showSettings,
      toggleSettings,
      saveApiKey,
      handleKeyPress,
      sendMessage,
      input_userInput_binding,
      settings_apiKey_binding
    ];
  }
  var App = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance6, create_fragment6, safe_not_equal, {});
    }
  };
  var App_default = App;

  // src/ui/ui.ts
  console.log("UI script loaded");
  console.log("document.body:", document.body);
  var app;
  if (document.body) {
    console.log("Mounting app immediately");
    app = new App_default({
      target: document.body
    });
  } else {
    console.log("Waiting for DOM ready");
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOM ready, mounting app");
      app = new App_default({
        target: document.body
      });
    });
  }
  var ui_default = app;
})();

                    </script>
                  </body>
                  </html>